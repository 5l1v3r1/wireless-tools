diff -u -p linux/net/core/rtnetlink.j1.c linux/net/core/rtnetlink.c
--- linux/net/core/rtnetlink.j1.c	Thu Mar  4 16:14:02 2004
+++ linux/net/core/rtnetlink.c	Thu Mar 11 17:30:17 2004
@@ -50,6 +50,10 @@
 #include <net/udp.h>
 #include <net/sock.h>
 #include <net/pkt_sched.h>
+#ifdef CONFIG_NET_RADIO
+#include <linux/wireless.h>		/* Note : will define WIRELESS_EXT */
+#include <net/iw_handler.h>
+#endif	/* CONFIG_NET_RADIO */
 
 DECLARE_MUTEX(rtnl_sem);
 
@@ -270,11 +274,24 @@ static int do_setlink(struct sk_buff *sk
 		       dev->addr_len);
 	}
 
+#ifdef WIRELESS_EXT
+	if (ida[IFLA_WIRELESS - 1]) {
+		printk(KERN_DEBUG "Calling wireless stuff\n");
+
+		/* Device validity/presence checked in there */
+		err = wireless_process_rtnetlink(skb, dev, RTA_DATA(ida[IFLA_WIRELESS - 1]), ida[IFLA_WIRELESS - 1]->rta_len);
+
+		/* Skip the notifier, we didn't change any address */
+		goto out2;
+	}
+#endif	/* WIRELESS_EXT */
+
 	err = 0;
 
 out:
 	if (!err)
 		call_netdevice_notifiers(NETDEV_CHANGEADDR, dev);
+out2:
 
 	dev_put(dev);
 	return err;
diff -u -p linux/net/core/wireless.j1.c linux/net/core/wireless.c
--- linux/net/core/wireless.j1.c	Thu Mar  4 16:13:52 2004
+++ linux/net/core/wireless.c	Fri Mar 12 18:38:53 2004
@@ -57,10 +57,12 @@
 #include <linux/types.h>		/* off_t */
 #include <linux/netdevice.h>		/* struct ifreq, dev_get_by_name() */
 #include <linux/proc_fs.h>
+#include <linux/netlink.h>		/* netlink stuff */
 #include <linux/rtnetlink.h>		/* rtnetlink stuff */
 #include <linux/seq_file.h>
 #include <linux/init.h>			/* for __init */
 #include <linux/if_arp.h>		/* ARPHRD_ETHER */
+#include <net/sock.h>			/* struct sock */
 
 #include <linux/wireless.h>		/* Pretty obvious */
 #include <net/iw_handler.h>		/* New driver API */
@@ -75,11 +77,13 @@
 
 /* Debugging stuff */
 #undef WE_IOCTL_DEBUG		/* Debug IOCTL API */
-#undef WE_EVENT_DEBUG		/* Debug Event dispatcher */
+#define WE_RTNETLINK_DEBUG	/* Debug RtNetlink API */
+#define WE_EVENT_DEBUG		/* Debug Event dispatcher */
 #undef WE_SPY_DEBUG		/* Debug enhanced spy support */
 
 /* Options */
-#define WE_EVENT_NETLINK	/* Propagate events using rtnetlink */
+#define WE_REQUEST_RTNETLINK	/* Access requests from RtNetlink */
+#define WE_EVENT_RTNETLINK	/* Propagate events using RtNetlink */
 #define WE_SET_EVENT		/* Generate an event on some set commands */
 
 /************************* GLOBAL VARIABLES *************************/
@@ -495,6 +499,7 @@ static struct file_operations wireless_s
 
 int __init wireless_proc_init(void)
 {
+	/* Create /proc/net/wireless entry */
 	if (!proc_net_fops_create("wireless", S_IRUGO, &wireless_seq_fops))
 		return -ENOMEM;
 
@@ -943,32 +948,62 @@ int wireless_process_ioctl(struct ifreq 
 	return -EINVAL;
 }
 
-/************************* EVENT PROCESSING *************************/
+/********************** RTNETLINK SUBROUTINES **********************/
 /*
- * Process events generated by the wireless layer or the driver.
- * Most often, the event will be propagated through rtnetlink
+ * RtNetlink helpers used by bother the main RtNetlink request API and
+ * the Wireless Events RtNetlink code.
  */
 
-#ifdef WE_EVENT_NETLINK
-/* "rtnl" is defined in net/core/rtnetlink.c, but we need it here.
- * It is declared in <linux/rtnetlink.h> */
+#if defined(WE_REQUEST_RTNETLINK) || defined(WE_EVENT_RTNETLINK)
+/* ---------------------------------------------------------------- */
+/*
+ * Fill a rtnetlink skb with a fragmented piece of data.
+ * This avoid copying around large chunks of data, and is therefore
+ * much more efficient...
+ * This is a clone of __rta_fill() in rtnetlink.c. Because of the
+ * padding, we need to change this function.
+ */
+static inline void __rta_fill_double(struct sk_buff *	skb,
+				     int		attrtype,
+				     int		attr1len,
+				     const void *	data1,
+				     int		attr2len,
+				     const void *	data2)
+{
+	struct rtattr *rta;
+	int size = RTA_LENGTH(attr1len + attr2len);
+
+	rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));
+	rta->rta_type = attrtype;
+	rta->rta_len = size;
+	memcpy(RTA_DATA(rta), data1, attr1len);
+	if(data2)
+		memcpy(RTA_DATA(rta) + attr1len, data2, attr2len);
+}
+
+#define RTA_PUT_DOUBLE(skb, attrtype, attr1len, data1, attr2len, data2) \
+({	if (unlikely(skb_tailroom(skb) < (int)RTA_SPACE(attr1len+attr2len))) \
+		 goto rtattr_failure; \
+   	__rta_fill_double(skb, attrtype, attr1len, data1, attr2len, data2); }) 
 
 /* ---------------------------------------------------------------- */
 /*
- * Fill a rtnetlink message with our event data.
- * Note that we propage only the specified event and don't dump the
+ * Fill a wireless_netlink message with our event data.
+ * Note that we propage only the specified reply/event and don't dump the
  * current wireless config. Dumping the wireless config is far too
- * expensive (for each parameter, the driver need to query the hardware).
+ * expensive : for each parameter, the driver need to query the hardware.
  */
-static inline int rtnetlink_fill_iwinfo(struct sk_buff *	skb,
-					struct net_device *	dev,
-					int			type,
-					char *			event,
-					int			event_len)
+static inline int wireless_rtnetlink_fill(struct sk_buff *	skb,
+					  struct net_device *	dev,
+					  int			type,
+					  char *		event,
+					  int			event_len,
+					  char *		extra,
+					  int			extra_len)
 {
-	struct ifinfomsg *r;
-	struct nlmsghdr  *nlh;
-	unsigned char	 *b = skb->tail;
+	struct nlmsghdr *	nlh;
+	struct ifinfomsg *	r;
+	unsigned char *		b = skb->tail;
 
 	nlh = NLMSG_PUT(skb, 0, 0, type, sizeof(*r));
 	r = NLMSG_DATA(nlh);
@@ -978,9 +1013,9 @@ static inline int rtnetlink_fill_iwinfo(
 	r->ifi_flags = dev->flags;
 	r->ifi_change = 0;	/* Wireless changes don't affect those flags */
 
-	/* Add the wireless events in the netlink packet */
-	RTA_PUT(skb, IFLA_WIRELESS,
-		event_len, event);
+	/* Add the wireless data in the netlink packet */
+	RTA_PUT_DOUBLE(skb, IFLA_WIRELESS,
+		       event_len, event, extra_len, extra);
 
 	nlh->nlmsg_len = skb->tail - b;
 	return skb->len;
@@ -993,31 +1028,284 @@ rtattr_failure:
 
 /* ---------------------------------------------------------------- */
 /*
- * Create and broadcast and send it on the standard rtnetlink socket
- * This is a pure clone rtmsg_ifinfo() in net/core/rtnetlink.c
+ * Create and send a wireless reply/event on the RtNetlink channel/
+ * This is a clone rtmsg_ifinfo() in net/core/rtnetlink.c
  * Andrzej Krzysztofowicz mandated that I used a IFLA_XXX field
  * within a RTM_NEWLINK event.
  */
-static inline void rtmsg_iwinfo(struct net_device *	dev,
-				char *			event,
-				int			event_len)
+static void wireless_rtnetlink_send(struct sk_buff *	in_skb,
+				    struct net_device *	dev,
+				    char *		event,
+				    int			event_len,
+				    char *		extra,
+				    int			extra_len)
 {
-	struct sk_buff *skb;
-	int size = NLMSG_GOODSIZE;
-
-	skb = alloc_skb(size, GFP_ATOMIC);
+	struct sk_buff *	skb;
+	int			nlmsize;
+	int			rtasize;
+
+	/* Size of the whole event */
+	nlmsize = NLMSG_LENGTH(sizeof(struct ifinfomsg));
+	rtasize = RTA_LENGTH(event_len + extra_len);
+	/* Allocate it */
+	skb = alloc_skb(nlmsize + rtasize, GFP_ATOMIC);
 	if (!skb)
 		return;
 
-	if (rtnetlink_fill_iwinfo(skb, dev, RTM_NEWLINK,
-				  event, event_len) < 0) {
+	/* Put our junk in it */
+	if (wireless_rtnetlink_fill(skb, dev,
+				    (in_skb ? RTM_SETLINK : RTM_NEWLINK),
+				    event, event_len, extra, extra_len) < 0) {
 		kfree_skb(skb);
 		return;
 	}
-	NETLINK_CB(skb).dst_groups = RTMGRP_LINK;
-	netlink_broadcast(rtnl, skb, 0, RTMGRP_LINK, GFP_ATOMIC);
+
+	/* Send to appropriate socket */
+	if(in_skb) {
+		/* Reply : Unicast to pid/process which made the query */
+		netlink_unicast(in_skb->sk, skb, NETLINK_CB(in_skb).pid,
+				MSG_DONTWAIT);
+	} else {
+		/* Event : Multicast to all processes */
+		NETLINK_CB(skb).dst_groups = RTMGRP_LINK;
+		netlink_broadcast(rtnl, skb, 0, RTMGRP_LINK, GFP_ATOMIC);
+	}
 }
-#endif	/* WE_EVENT_NETLINK */
+#endif	/* WE_REQUEST_RTNETLINK || WE_EVENT_RTNETLINK */
+
+/********************** RTNETLINK REQUEST API **********************/
+/*
+ * The alternate user space API to configure all those Wireless Extensions
+ * is through RtNetlink.
+ * This API support only the new driver API (iw_handler).
+ * This is still experimental.
+ *
+ * This RtNetlink API use the same query/reply model as the ioctl API.
+ * This is in contrast to the rest of the RtNetlink API only offer
+ * Set and Dump operations.
+ * We can't offer Dump operations because of the following reasons :
+ *	o Large number of parameters, most optional
+ *	o Large size of some parameters (> 100 bytes)
+ *	o Each parameters need to be extracted from hardware
+ *	o Scan requests can take seconds and disable network activity.
+ * Because of this high cost/overhead, we want to return only the
+ * parameters the user application is really interested in.
+ *
+ * The API uses the standard RtNetlink socket. When the RtNetlink code
+ * find a IFLA_WIRELESS field in a RtNetlink SET_LINK request,
+ * it calls here.
+ */
+
+#ifdef WE_REQUEST_RTNETLINK
+/* ---------------------------------------------------------------- */
+/*
+ * Wrapper to call a standard Wireless Extension handler.
+ * We do various checks and call the handler with the proper args.
+ */
+static inline int rtnetlink_standard_call(struct sk_buff *	in_skb,
+					  struct net_device *	dev,
+					  struct iw_event *	request,
+					  int			request_len,
+					  iw_handler		handler)
+{
+	const struct iw_ioctl_description *	descr = NULL;
+	unsigned int				cmd;
+	union iwreq_data *			wrqu;
+	int					hdr_len;
+	char *					extra = NULL;
+	int					extra_len = 0;
+	struct iw_request_info			info;
+	int					ret = -EINVAL;
+
+	/* Get the description of the Request */
+	cmd = request->cmd;
+	if((cmd - SIOCIWFIRST) >= standard_ioctl_num)
+		return -EOPNOTSUPP;
+	descr = &(standard_ioctl[cmd - SIOCIWFIRST]);
+
+#ifdef WE_RTNETLINK_DEBUG
+	printk(KERN_DEBUG "%s (WE) : Found standard handler for 0x%04X\n",
+	       dev->name, cmd);
+	printk(KERN_DEBUG "%s (WE) : Header type : %d, Token type : %d, size : %d, token : %d\n", dev->name, descr->header_type, descr->token_type, descr->token_size, descr->max_tokens);
+#endif	/* WE_RTNETLINK_DEBUG */
+
+	/* Extract fixed header from request. This is properly aligned. */
+	wrqu = (union iwreq_data *) &request->u;
+
+	/* Prepare the call */
+	info.cmd = cmd;
+	info.flags = 0;
+
+	/* Check if wrqu is complete */
+	hdr_len = event_type_size[descr->header_type];
+	if(request_len < hdr_len) {
+#ifdef WE_RTNETLINK_DEBUG
+		printk(KERN_DEBUG
+		       "%s (WE) : Wireless request too short (%d)\n",
+		       dev->name, request_len);
+#endif	/* WE_RTNETLINK_DEBUG */
+		return -EINVAL;
+	}
+
+	/* Check if we have extra data in the request or not */
+	if(descr->header_type != IW_HEADER_TYPE_POINT) {
+
+		/* No extra arguments. Trivial to handle */
+		ret = handler(dev, &info, wrqu, NULL);
+	} else {
+		/* Check what user space is giving us */
+		if(IW_IS_SET(cmd)) {
+			/* Check if number of token fits within bounds */
+			if(wrqu->data.length > descr->max_tokens)
+				return -E2BIG;
+			if(wrqu->data.length < descr->min_tokens)
+				return -EINVAL;
+		}
+
+#ifdef WE_RTNETLINK_DEBUG
+		printk(KERN_DEBUG "%s (WE) : Malloc %d bytes\n",
+		       dev->name, descr->max_tokens * descr->token_size);
+#endif	/* WE_RTNETLINK_DEBUG */
+
+		/* Always allocate for max space. Easier, and won't last
+		 * long... */
+		extra = kmalloc(descr->max_tokens * descr->token_size,
+				GFP_KERNEL);
+		if (extra == NULL) {
+			return -ENOMEM;
+		}
+
+		/* If it is a SET, copy data to the aligned buffer */
+		if(IW_IS_SET(cmd)) {
+
+			/* Length of extra (what's after the fixed header) */
+			extra_len = request_len - hdr_len;
+
+			/* Check if we have enough of it */
+			if(extra_len < (wrqu->data.length *
+					descr->token_size)) {
+#ifdef WE_RTNETLINK_DEBUG
+				printk(KERN_DEBUG "%s (WE) : Wireless request data too short (%d)\n",
+				       dev->name, extra_len);
+#endif	/* WE_RTNETLINK_DEBUG */
+				return -EINVAL;
+			}
+
+			/* Copy extra in aligned buffer */
+			if(wrqu->data.length != 0)
+				memcpy(extra, ((char *) request) + hdr_len,
+				       extra_len);
+		}
+
+		/* Call the handler */
+		ret = handler(dev, &info, wrqu, extra);
+
+		/* Calculate real returned length for GETs */
+		if(!ret && IW_IS_GET(cmd))
+			extra_len = (wrqu->data.length * descr->token_size);
+		/* For SET, extra_len is already correct */
+	}
+
+	/* If we have something to return to the user */
+	if(!ret && IW_IS_GET(cmd)) {
+		/* Reuse the request as the reply. Both wrqu and extra
+		 * have been modified by the handler. We just need to
+		 * update the event header. */
+		request->len = hdr_len + extra_len;
+
+#ifdef WE_RTNETLINK_DEBUG
+		printk(KERN_DEBUG "%s (WE) : Reply 0x%04X, hdr_len %d, tokens %d, extra_len %d, request->len %d\n", dev->name, cmd, hdr_len, wrqu->data.length, extra_len, request->len);
+#endif	/* WE_RTNETLINK_DEBUG */
+
+		/* Send the reply to the requesting process. */
+		wireless_rtnetlink_send(in_skb, dev,
+					(char *) request, hdr_len,
+					extra, extra_len);
+	}
+
+#ifdef WE_SET_EVENT
+	/* Generate an event to notify listeners of the change */
+	if((descr->flags & IW_DESCR_FLAG_EVENT) &&
+	   ((ret == 0) || (ret == -EIWCOMMIT))) {
+		// TODO : use generic mux (older version) (event->len)
+		if(descr->flags & IW_DESCR_FLAG_RESTRICT)
+			/* If the event is restricted, don't
+			 * export the payload */
+			wireless_send_event(dev, cmd, wrqu, NULL);
+		else
+			wireless_send_event(dev, cmd, wrqu, extra);
+	}
+#endif	/* WE_SET_EVENT */
+
+	/* Cleanup - I told you it wasn't that long ;-) */
+	if(extra)
+		kfree(extra);
+
+	/* Call commit handler if needed and defined */
+	if(ret == -EIWCOMMIT)
+		ret = call_commit_handler(dev);
+
+	return ret;
+}
+#endif	/* WE_REQUEST_RTNETLINK */
+
+/* ---------------------------------------------------------------- */
+/*
+ * Main RtNetlink dispatcher. Called from the main networking code
+ * (do_setlink() in net/core/rtnetlink.c).
+ * Check the type of Request and call the appropriate wrapper...
+ */
+int wireless_process_rtnetlink(struct sk_buff *		in_skb,
+			       struct net_device *	dev,
+			       char *			data,
+			       int			len)
+{
+#ifdef WE_REQUEST_RTNETLINK
+	struct iw_event *	request = (struct iw_event *) data;
+	iw_handler		handler;
+
+	/* Check length */
+	if(len < IW_EV_LCP_LEN) {
+		printk(KERN_DEBUG "%s (WE) : RtNetlink request too short (%d)\n",
+		       dev->name, len);
+		return -EINVAL;
+	}
+
+	/* ReCheck length (len may have padding) */
+	if(request->len > len) {
+		printk(KERN_DEBUG "%s (WE) : RtNetlink request len invalid (%d-%d)\n",
+		       dev->name, request->len, len);
+		return -EINVAL;
+	}
+
+	// TODO : Handle special cases
+
+	/* Basic check */
+	if (!netif_device_present(dev))
+		return -ENODEV;
+
+	/* New driver API : try to find the handler */
+	handler = get_handler(dev, request->cmd);
+	if(handler != NULL) {
+		/* Standard and private are not the same */
+		if(request->cmd < SIOCIWFIRSTPRIV)
+			return rtnetlink_standard_call(in_skb,
+						       dev,
+						       request,
+						       request->len,
+						       handler);
+		// TODO : support for Private Requests
+	}
+#endif	/* WE_REQUEST_RTNETLINK */
+
+	return -EOPNOTSUPP;
+}
+
+/************************* EVENT PROCESSING *************************/
+/*
+ * Process events generated by the wireless layer or the driver.
+ * Most often, the event will be propagated through rtnetlink
+ */
 
 /* ---------------------------------------------------------------- */
 /*
@@ -1038,7 +1326,7 @@ void wireless_send_event(struct net_devi
 	/* Don't "optimise" the following variable, it will crash */
 	unsigned	cmd_index;		/* *MUST* be unsigned */
 
-	/* Get the description of the IOCTL */
+	/* Get the description of the Event */
 	if(cmd <= SIOCIWLAST) {
 		cmd_index = cmd - SIOCIWFIRST;
 		if(cmd_index < standard_ioctl_num)
@@ -1095,6 +1383,7 @@ void wireless_send_event(struct net_devi
 #endif	/* WE_EVENT_DEBUG */
 
 	/* Create temporary buffer to hold the event */
+	// TODO -> hdr_len
 	event = kmalloc(event_len, GFP_ATOMIC);
 	if(event == NULL)
 		return;
@@ -1106,10 +1395,11 @@ void wireless_send_event(struct net_devi
 	if(extra != NULL)
 		memcpy(((char *) event) + hdr_len, extra, extra_len);
 
-#ifdef WE_EVENT_NETLINK
-	/* rtnetlink event channel */
-	rtmsg_iwinfo(dev, (char *) event, event_len);
-#endif	/* WE_EVENT_NETLINK */
+#ifdef WE_EVENT_RTNETLINK
+	/* Send via the RtNetlink event channel */
+	wireless_rtnetlink_send(NULL, dev, (char *) event, hdr_len,
+				(char *) extra, extra_len);
+#endif	/* WE_EVENT_RTNETLINK */
 
 	/* Cleanup */
 	kfree(event);
